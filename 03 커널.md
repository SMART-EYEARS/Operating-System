# 커널과 세션 
💡 Kernel(커널)이란?    
💡 인터럽트가 필요한 이유 및 언제 발생되는지 말해주세요.   
💡 인터럽트 종류는 무엇이 있으며 우선순위를 말해주세요.  
💡 인터럽트 동작 과정을 말해주세요.   
💡 시스템콜이란 무엇이며 시스템 콜을 사용하는 예시를 말해주세요.  
💡 커널 모드와 유저 모드를 구분해 놓은 이유   
💡 커널 수준 스레드와 사용자 수준 스레드의 각각 장단점?  

# 커널
> 인간과 하드웨어간의 `통역사`      
> 하드웨어와 프로세스 운용을 위한 OS의 일부분이며, 소프트웨어이다      
    
커널은 이름(알맹이/핵심) 그대로 **운영체제의 핵심 부분을 의미한다.**           
      
* **보안 :** `컴퓨터 하드웨어`와 `프로세스의 보안`을 책임진다.      
* **자원 관리 :** `한정된 시스템 자원을 효율적으로 관리`하여 프로그램의 실행을 원활하게 한다.    
* **추상화 :** 비슷한 종류의 `하드웨어에 공통된 명령어(인터페이스)를 제공`한다.       
              
커널은 기본적으로 몇가지의 작업을 수행하는 것이 보편적이다.     
       
* **메모리 관리 :**              
  메모리의 하드웨어적 제원은 항상 제한되어 있다.            
  이 제한된 메모리를 여러 프로세스에 동시에 할당하기에는 부족한 경우        
  커널이 적극 개입하여 `메모리를 적절한 시기에 각각의 프로세스에 할당`해준다.        
  즉, 여러 프로세스를 동시에 구동하여야 하는 경우              
  커널은 이 프로세스들을 구동하기 위해 `메모리를 할당하고 관리`한다.         
                     
* **프로세스 스케줄링 :**       
  리눅스는 선점형 멀티 태스킹을 기반으로 한다.       
  그렇기에 멀티태스킹시에 프로세스에 대한 스케줄을 제어하지 않으면       
  각각의 프로세스에 대한 공정한, 효율적인 CPU 할당이 불가능할 수도 있다.        
  그렇기에, 커널은 메모리에 올라와 있는 프로세스에 대한 CPU 사용 우선순위와 같은 스케줄을 관리한다.     
               
* **디바이스 드라이버 제공 :**     
  컴퓨터는 다양한 외부장치를 사용하는데, 이들은 각각의 고유한 사용방법이 있다.     
  그리고 이러한 사용방법을 컴퓨터가 모른다면 사용할 수 없다.     
  이러한 사용방법(인터페이스)를 디바이스 드라이버라고 하는데 커널에서 이를 지원해준다.     
  즉, 커널에서 자체적으로 HW에 대한 디바이스 인터페이스를 가지고 있고    
  HW 제조업체에서는 해당 인터페이스에 맞춰서 HW를 제조하면 우리는 별 문제없이 HW를 사용할 수 있고      
  문제가 있더라도 우리가 수동으로 드라이버를 다운받으면 된다.(커널은 디바이스 드라이버 편의성제공)     
       
* **프로세스 생성, 종료**      
  메모리 관리나 프로세스 스케줄링을 커널이 직접 관장하고 있다.       
  새로운 프로세스가 실행될 때(new),     
  해당 프로세스 입장에서는 메모리에 어느 부분에 올라가야되는지 알 수 없다.      
  또한, 종료 직전 다른 프로세스에게 자신의 종료를 알리게 되면 보안에 문제가 생길 수 있다.    
  그렇기에 커널에서 이를 관리하여 매니징 역할을 해주고 있다.       
  (메모리 어느 부분에 올릴지, 특정 프로세스에게 독립된 다른 프로세스의 종료를 대신 알린다.)         
        
* **파일 유틸리티 시스템 제공**     
  우리가 흔히 알고있는 파일 탐색기는 커널에서 자체적으로 제공해주는 것이다.     
  유저가 파일을 관리하면, 의도치 않은 손상을 불러일으킬 가능성이 크기에 이를 커널에 맡긴 것이다.   
      
* **네트워크**     
  OSI 7 Layer의 물리적인 혹은 LOW LEVEL에서의 논리적인 기능은 커널이 관장한다.       
  단지 우리는, 각각의 계층이 무엇을 어떻게 작업하여 어떤 정보를 보내줄지를 설계하면 된다.      
  (우리는 사용법만 알면 된다.)        
    
* **시스템 호출 API 제공**     
  보안과 같은 문제로 프로세스가 직접 실행할 수 없는 것들을 커널이 대신 맡아준다. (드라이버, 파일)       
  프로세스는 해당 정보가 필요할 때, 커널에게 요청하여 적정성 검사를 한 후 데이터를 응답해준다.     
                          
# 커널의 종류       
## 모놀리틱(단일형) 커널   
초창기의 구조로,        
커널의 다양한 서비스 및 높은 수준의 하드웨어 추상화를 `하나의 덩어리`로 묶은 것이다.          
운영 체제 개발자 입장에서 유지 보수가 일반적을오 더 어려우나 성능이 좋다.             
   
장점 : 
* 모듈들이 거의 분리되어 있지 않기 때문에, 모듈간의 통신 비용이 줄어들어 성능이 좋다.     
   
단점 :     
* 버그나 오류발생시에 여러 기능들이 상호 의존성이 높기 때문에        
  작은 결함에도 시스템 전체가 위험해지고 처리 또한 매우 까다롭다.          
  운영체제가 커지고 복잡해질 수록 구현하기 매우 어렵다.        
      
## 마이크로 커널       
하드웨어 추상화에 대한 간결한 작은 집합을 제공하고        
더 많은 기능은 서버라고 불리는 응용 소프트웨어를 통해 제공한다.       
      
장점 :         
* 커널의 크기가 작으므로 커널과 일부 서비스만으로 작은 운영체제를 구성하여 임베디드 시스템에 사용할 수 있다.     
* 하나의 커널로 다수의 운영체제를 동시에 수행시킬 수 있으며 이식성이 좋다.     
* 모듈 크기가 굉장히 작아졌기 때문에, 안정성이 높아졌다.     
* 각 모듈이 독립적으로 작동하기 때문에 하나의 모듈이 실패하더라도 전체 운영체제가 멈추지 않는다.       
    
단점 :     
* 잦은 통신이 필요하기 때문에 성능 저하의 우려가 있다.        
   
## 이외에도       
### 계층형 커널     
비슷한 기능을 가진 모듈들을 묶어 계층을 만들고, 계층간의 통신을 통해 운영체제를 구현하는 방식이다.     

장점 :    
* 단일형 구조보다 버그나 오류를 쉽게 처리할 수 있으며 비교적 디버깅이 쉽다.   
     
단점 :      
* 상하관계가 생기기 때문에 하나의 계층에 이상이 생기면 위, 아래 계층도 동작하지 못할 수도 있다.       
* 운영체제가 커지고 복잡해지면, 많은 계층들이 발생하게 되어 커널의 크기도 커지고 하드웨어의 용량도 늘어난다.     
        
## 하이브리드 커널   
모놀리틱 커널과 마이크로 커널의 개념을 합친 커널이다.         
하지만, 마이크로 커널의 일부분이라는 평가가 주로 이룬다.         
     
# 운영체제의 동작       
현대 운영체제는 **[인터럽트](https://ko.wikipedia.org/wiki/%EC%9D%B8%ED%84%B0%EB%9F%BD%ED%8A%B8) 구동식** 이다.           
아무런 작업이 예정되어 있지 않다면 운영체제 역시 아무런 작업 없이 조용히 대기한다.            
결국에는 `인터럽트(H/W 요청)`나 `트랩(S/W 요청)`을 발생시켜 신호를 발생시킨다.         

## 명령어의 종류     
CPU가 수행하는 명령에는 `일반 명령`과 `특권 명령`이 있다.     
  
* 일반 명령 :  
  메모리에서 자료를 읽어오고, CPU에서 계산을 하는 등의 명령     
  모든 프로그램이 수행할 수 있는 명령이다.     
* 특권 명령 :    
  보안이 필요한 명령으로 입출력 장치, 타이머 등의 장치를 접근하는 명령이다     
  특권 명령은 항상 `운영체제`만이 수행할 수 있다.      
       
## 이중 동작 모드       
이중 동작 모드는 쉽게 말해 운영체제를 보호하기 위한 기법이다.          
알다시피, `사용자`와 `운영체제`는 **시스템 자원을 공유한다.**           
그렇기 때문에, 사용자에게 제한을 두지 않으면 **사용자가 메모리 내의 주요 운영체제 자원을 망가뜨릴 위험이 생기게 된다.**       
즉, 운영체제의 원활한 작동과 기능을 위해서는 `사용자의 시스템 자원 접근을 제한하는 보호 장치가 필수불가결하다`              
그리고 이러한 보호 장치가 바로 `이중 동작 모드(dual-mode operation)`이다.         
     
이중 동작 모드의 기본 개념은        
`사용자가 접근할 수 없는 커널 모드(kernel mode)`와     
`사용자가 접근할 수 있는 사용자 모드(user mode)`로 나누어 진다.      
  
`커널 모드`는 운영체제가 CPU의 제어권을 가지고 명령을 수행하는 모드로      
`일반 명령`과 `특권 명령` 모두 수행할 수 있다.        
  
`사용자 모드`는 일반 사용자 프로그램이 CPU 제어권을 가지고 명령을 수행하는 모드기이기 때문에,     
`일반 명령`만을 수행할 수 있다.      
      
참고로, 컴퓨터 최초 부팅시 H/W는 `커널 모드`에서 시작된다.               
운영체제가 이 위에 올라오고 여기서부터 `사용자 모드`가 시작된다.            
  
# 시스템 콜    
운영체제는 커널모드와 사용자모드로 나뉘어 구동된다.      
커널과 관련된 모든 작업들은 커널모드로 전환한 후에야 해당 작업을 수행할 **권한**이 생긴다.      
파일을 읽어 오거나, 파일을 쓰거나, 혹은 화면에 메시지를 출력하는 등 많은 부분이 커널 모드를 사용한다.         
하지만, 간혹 `사용자 모드`에서도 `커널 모드`의 기능을 사용해야하는 경우가 있다.             
            
시스템 콜은 이러한 `커널 모드 영역의 기능`을 `사용자 모드`가 사용가능하게끔           
즉, `프로세스`가 `하드웨어에 직접 접근`해서 필요한 기능을 사용할 수 있게 해준다.               
            
**그렇다면 `권한`은 왜 필요한거지 🤔?**      
커널과 관련된 영역들은 시스템과의 밀접도가 높아       
만약 해커가 악의적인 의도로 시스템을 망치거나 피해를 입힐 수 있기 때문에 권한이 필요하다.     
     
```terminal  
cp in.txt out.txt
``` 
일반적으로 윈도우 운영체제라면 라면 마우스가,           
리눅스라면 키보드가 사용자로부터 입력을 받는데 이때 I/O 시스템 콜을 사용한다.           
             
위와 같은 문장을 입력을 받아서 실행시키면            
먼저 현재 디렉터리에서 접근할 수 있는 파일인지를 검사하기 위해 시스템 콜을 호출한다.   
만약 파일이 존재하지 않는 다면 에러를 발생시켜야 하고, 프로그램을 종료하는데 이때 시스템 콜이 사용된다.      
만약 파일이 존재한다면, 복사한 파일을 저장하기 위해 `output.txt` 파일명이 있는지 검사합니다.      
그리고 이 때도 마찬가지로 이 파일 명이 존재하는지 존재하지 않는지 검사하기 위해 시스템 콜을 통해 확인한다.     
그리고 만약 파일 명이 이미 존재한다면, 덮어 씌워야 할지 아니면, 이어서 붙여야 하는지 User에게 물어볼 수 있다.     
만약 저장하고자 하는 파일 이름이 겹치지 않다면, 파일을 저장해야 하는데 이 때도 시스템 콜을 이용한다.      
     
## 시스템 콜의 유형 
시스템 콜은 다섯 가지의 중요한 범주로 나눌 수 있다.   

* 프로세스 제어
* 파일 조작
* 장치 조작
* 정보 유지보수
* 통신과 보호

### 프로세스 제어(Process Control)
* 끝내기(end), 중지(abort)
* 적재(load), 실행(execute)
* 프로세스 생성(create process)
* 프로세스 속성 획득과 설정(get process attribute and set process attribute)
* 시간 대기(wait time)
* 사건 대기(wait event)
* 사건을 알림(signal event)
* 메모리 할당 및 해제 : malloc, free


### 파일 조작(File Manipulation)
* 파일 생성(create file), 파일 삭제(delete file)
* 열기(open), 닫기(close)
* 읽기(read), 쓰기(write), 위치 변경(reposition)
* 파일 속성 획득 및 설정(get file attribute and set file attribute)


### 장치 관리(Devide Management)
* 장치를 요구(request devices), 장치를 방출release device)
* 읽기, 쓰기, 위치 변경
* 장치 속성 획득, 장치 속성 설정
* 장치의 논리적 부착(attach) 또는 분리(detach)


### 정보 유지(Information Maintenance)
* 시간과 날짜의 설정과 획득(time)
* 시스템 데이터의 설정과 획득(date)
* 프로세스 파일, 장치 속성의 획득 및 설정


### 통신(Communication)
* 통신 연결의 생성, 제거
* 메시지의 송신, 수신
* 상태 정보 전달
* 원격 장치의 부착 및 분리
      
# 커널/사용자 수준의 스레드       
OS는 멀티프로세스를 지원하는지, 지원하지 않는지로 나뉜다.        
또한, 스레드를 지원하는 OS가 있고, 스레드를 지원하지 않는 OS도 있다.          
대표적으로 UNIX가 있다.(과거에는 지원안했다. 지금은 한다.)      
      
스레드를 지원한다는 것은 커널 레벨에서 커널이 스레드를 제공한다는 것이다.      
반대로, 스레드를 지원하지 않는 다는 것은 커널이 스레드라는 기능 제공하지 않는다.       
그런데 우리가 사용하는 대다수의 애플리케이션은 스레드를 기반으로 돌아간다. 그럼 어떻게 할까?   
우리가 자주 사용하는 언어들의 대다수는 스레드 라이브러리를 지원한다.   
스레드를 제공하지 않는 OS는 이런 라이브러리를 통해 스레드를 실행시키는 것이다.   
(사실 OS 의 커널도 하나의 프로그램이자 소프트웨어일뿐이다, 이를 라이브러리에 갖다 놓은 것이다.)    
      
이렇듯 커널에서 스레드 기능을 제공하고 이를 사용한다면 커널 레벨 스레드    
커널에서 스레드를 제공하지 않아, 라이브러리를 통해 스레드를 실행하면 이는 사용자 레벨 스레드라고 말한다.   
즉, 큰 차이점은 누가 만들어서 제공해주는 것이냐이다.     
        

커널 레벨 스레드
- 커널 스레드는 가장 가벼운 커널 스케쥴링 단위다. 
- 하나의 프로세스는 적어도 하나의 커널 스레드를 가지게 된다. 
- 커널 영역에서 스레드 연산을 수행하게 된다.
- 커널이 스레드를 관리하기 때문에 커널에 종속적이다.
- 프로그래머 요청에 따라 스레드를 생성하고 스케줄링하는 주체가 커널이면 커널 레벨(Kernel Level) 스레드라고 한다.


커널 레벨 스레드 장점
- 프로세스의 스레드들을 몇몇 프로세서에 한꺼번에 디스패치 할 수 있기 때문에 멀티프로세서 환경에서 매우 빠르게 동작한다.
- 다른 스레드가 입출력 작업이 다 끝날 때까지 다른 스레드를 사용해 다른 작업을 진행할 수 있다. 
- 커널이 각 스레드를 개별적으로 관리할 수 있다. 
- 커널이 직접 스레드를 제공해 주기 때문에 안정성과 다양한 기능이 제공된다.

커널 레벨 스레드 단점
- 스케줄링과 동기화를 위해 커널을 호출하는데 무겁고 오래걸린다.(저장한 내용을 다시 불러오는 과정이 필요)
- 즉, 사용자 모드에서 커널 모드로의 전환이 빈번하게 이뤄져 성능 저하가 발생한다.
- 사용자가 프로그래밍할 때 구현하기 어렵고 자원을 더 많이 소비하는 경향이 있다.


사용자 레벨 스레드
- 사용자 영역에서 스레드 연산을 수행한다. 
- 사용자 영역에서 스레드 연산을 수행하기 때문에 운영체제에 투명하다. 
- 커널에 의존적이지 않은 형태로 스레드의 기능을 제공하는 라이브러리를 활용하는 방식이 사용자 레벨(User Level) 스레드다.

사용자 레벨 스레드 장점
- 운영체제에서 스레드를 지원할 필요가 없다. 
- 스케줄링 결정이나 동기화를 위해 커널을 호출하지 않기 때문에 인터럽트가 발생할 때 커널 레벨 스레드보다 오버헤드가 적다.
- 즉, 위의 말은 사용자 영역 스레드에서 행동을 하기에 OS Scheduler의 context switch가 없다(유저레벨 스레드 스케줄러를 이용).
- 커널은 사용자 레벨 스레드의 존재조차 모르기 때문에 모드 간의 전환이 없고 성능 이득이 발생한다

사용자 레벨 스레드 단점
- 시스템 전반에 걸친 스케줄링 우선순위를 지원하지 않는다. (무슨 스레드가 먼저 동작할 지 모른다.)
- 프로세스에 속한 스레드 중 I/O 작업등에 의해 하나라도 블록이 걸린다면 전체 스레드가 블록된다.












    
   
