# 스레드(Thread)
     
스레드는 **프로세스의 실행 단위라고 할 수 있다.**          
`한 프로세스 내`에서 동작되는 `여러 실행 흐름`으로 **프로세스 내의 주소 공간이나 자원을 공유할 수 있다.**   
         
스레드는 `스레드 ID`, `프로그램 카운터`, `레지스터 집합`, 그리고 `스택`으로 구성된다.     
같은 프로세스에 속한 다른 스레드와 **코드, 데이터 섹션, 그리고 열린 파일이나 신호와 같은 운영체제 자원들을 공유한다.**   
         
하나의 프로세스를 다수의 실행 단위로 구분하여 자원을 공유하고        
자원의 생성과 관리의 중복성을 최소화하여 수행 능력을 향상시키는 것을 `멀티스레딩`이라고 한다.      
이 경우 각각의 스레드는 독립적인 작업을 수행해야 하기 때문에 각자의 `스택`과 `PC 레지스터` 값을 갖고 있다.
   
## 스택을 스레드마다 독립적으로 할당하는 이유

스택은 함수 호출 시 `전달되는 인자`, `되돌아갈 주소값` 및 `함수 내에서 선언하는 변수`등을 저장하기 위해 사용되는 메모리 공간이므로       
스택 메모리 공간이 독립적이라는 것은 **독립적인 함수 호출이 가능하다는 것이고 이는 독립적인 실행 흐름이 추가되는 것이다.**       
따라서 스레드의 정의에 따라 **독립적인 실행 흐름을 추가하기 위한 최소 조건으로 독립된 스택**을 할당한다.     
   
### 번외 람다에서 알아보는 스레드와 병렬처리       
`Variable Capture`란 `Lambda`의 익명 클래스 생성을 활용한 방법으로         
`Lambda` 외부에서 참조변수를 통해 `Lambda`를 통해 생성된 익명클래스를 참조한다.   
           
하지만, `Variable Capture` 에는 한 가지 조건이 있다.              
바로, `Lambda` 식에서 사용하는 캡처된 변수들은 **`effectively final`이어야 한다.**               
              
```
캡처된 변수란?        
중첩 된 클래스에서 사용할 수 있도록 복사 된 변수를 뜻한다.              
즉, 매개변수로 들어온 복사된 값이 아닌 실제 값을 사용한다고 생각하면 된다.         
```

보다 정확히 설명하면, 익명 클래스는 그들을 둘러싼 영역(메서드)의 지역 변수를 캡처할 수 있다.           
하지만, 캡처된 지역 변수는 해당 메서드 스택 영역에만 존재하는 지역 변수이며            
`JVM 메모리 구조 특성상 스레드간의 공유가 되지 않는다`는 문제가 있다.     
       
* **서로 다른 스레드끼리 지역변수를 공유할 수 없다.**    
                           
이러한 이유에 대해서도 설명하자면                    
스레드에서 `해당 영역(메서드)`이 종료되면 `지역 변수` 또한, 메모리에 `쓰레기 값으로 남겨진다.`               
하지만, 다른 스레드에 `공유된 객체`가 동작을 할 때 `해당 지역 변수`를 사용한다면?                                   
**`공유된 객체`는 해당 지역 변수의 메모리를 가지고 `접근할 수 있다는 문제가 발생`한다.**                  
              
또한, 스택이 해제되면서 해당 `지역 변수가 존재했던 메모리 영역` 또한,            
언제든 **새로운 메모리로 할당되어 값이 변형될 수 있기에**                      
**`공유된 객체`도 항상 일정한 로직을 실행한다는 보장을 할 수 없다.**                 
                  
그렇기에 스레드간의 지역 변수를 공유하지 못하도록 한 것이며       
이는 다른 프로그래밍 언어에서도 마찬가지이다.      
     
반대로, 객체나 정적 요소들은 왜 사용이 가능한 것인가?        
이는 메모리 구조에 대한 연장선으로 이들은 `클래스 영역`이나 `힙 영역`에 존재한다.     
이들은 스레드들 간에 공유를 해도 문제가 없기에 사용을 가능하도록 설정한 것이다.    
   
**익명 클래스**
```java
   JButton button = new JButton("Press me!");
   String message = "Never been pressed";
   button.addActionListener(new ActionListener() {

      @Override
      public void actionPerformed(ActionEvent e) {
         message = "Pressed";
      }
          
   });
```
**결과**    
```java
Cannot refer to a non-final variable message inside an inner class defined in a different method
```  
   
다시 본론으로 돌아와서        
Java 컴파일러는 `외부` 변수와 `내부` 변수 값 사이의 불일치를 피하기 위해      
캡처된 모든 변수가 `effectively final`임을 확인을 하고 아닐 경우, 에러를 발생시킨다.                 
                          
또한, Java는 로컬 변수의 **복사본을 만들고** 내부 클래스에 대한 **참조로 제공**한다.          
그리고 두 복사본 간의 일관성을 유지하기 위해 지역 변수는 `final`로 제한을 두었다.             

하지만, 앞서 `effectively final`임을 확인한다고 했다.      
**그렇다면 `effectively final`는 무엇일까? 🤔**   
              
**`effectively final`이란** Java 8 에 추가된 syntactic sugar 일종으로,     
**초기화 된 이후 값이 한번도 변경되지 않은 것을 의미한다.**                       
`effectively final`변수는 `final` 키워드가 붙어있지 않았지만 값이 변형되지 않았기에    
**`final` 키워드를 붙힌 것과 동일하게 컴파일러에서 처리한다.**           
그리고 이러한 특성 덕분에 람다/익명 클래스에서 무리없이 사용이 가능하다.  

      
## PC Register 를 스레드마다 독립적으로 할당하는 이유
          
PC 값은 스레드가 명령어의 어디까지 수행하였는지를 나타나게 된다.        
스레드는 CPU 를 할당받았다가 스케줄러에 의해 다시 선점당한다.         
그렇기 때문에 `명령어가 연속적으로 수행되지 못하고 어느 부분까지 수행했는지 기억할 필요가 있다.` -> PCB처럼        
따라서 **PC 레지스터를 독립적으로 할당한다.**         
     
PC 레지스터 : 다음에 실행될 명령어의 주소를 가지고 있어 실행할 기계어 코드의 위치를 지정한다.   
         
# 멀티 스레드  
## 멀티 스레딩의 장점
       
프로세스를 이용하여 동시에 처리하던 일을 스레드로 구현할 경우 **메모리 공간과 시스템 자원 소모가 줄어들게 된다. -> 공유하니까**        
스레드 간의 통신이 필요한 경우에도 별도의 자원을 이용하는 것이 아니라 **전역 변수의 공간 또는 동적으로 할당된 공간인 Heap 영역을 이용하여 데이터를 주고받을 수 있다.**   
그렇기 때문에 프로세스 간 통신 방법에 비해 스레드 간의 통신 방법이 훨씬 간단하다. 
   
* 잠깐 -> stack 은 공유하지 않고 heap을 공유한다고? -> 객체는 공유가능 -> 공유가능하니까 synchronized로 임계영역 lock 건다.     
    
심지어 스레드의 `context switch`는 프로세스 `context switch`와는 달리 **캐시 메모리를 비울 필요가 없기 때문에 더 빠르다.**     
따라서 시스템의 `throughtput`이 향상되고 자원 소모가 줄어들며 **자연스럽게 프로그램의 응답 시간이 단축된다.**           
이러한 장점 때문에 **여러 프로세스로 할 수 있는 작업들을 하나의 프로세스에서 스레드로 나눠 수행하는 것이다.**          
   
## 멀티 스레딩의 문제점
  
멀티 프로세스 기반으로 프로그래밍할 때는     
프로세스 간 공유하는 자원이 없기 때문에 동일한 자원에 동시에 접근하는 일이 없었지만      
멀티 스레딩을 기반으로 프로그래밍할 때는 이 부분을 신경써줘야 한다.         
서로 다른 스레드가 데이터와 `힙 영역을 공유`하기 때문에       
어떤 스레드가 다른 스레드에서 사용중인 변수나 자료구조에 접근하여 **엉뚱한 값을 읽어오거나 수정할 수 있다.**     
    
그렇기 때문에 멀티스레딩 환경에서는 **동기화 작업이 필요하다.**   
동기화를 통해 작업 처리 순서를 컨트롤 하고 공유 자원에 대한 접근을 컨트롤 하는 것이다.    
하지만 이로 인해 `병목현상이 발생`하여 성능이 저하될 가능성이 높다.    
그러므로 과도한 락으로 인한 병목현상을 줄여야 한다.
         
**그럼 여기서 문제 -> 서버(Controller)는 여러 접속을 받을텐데 synchronized로 처리할까?**        

## 멀티 스레드 vs 멀티 프로세스
   
`멀티 스레드`는 `멀티 프로세스`보다 **적은 메모리 공간을 차지하고 문맥 전환이 빠르다는 장점이 있지만,**    
오류로 인해 `하나의 스레드가 종료되면 전체 스레드가 종료될 수 있다는 점`과 `동기화 문제`를 안고 있다.       
반면 멀티 프로세스 방식은 `하나의 프로세스가 죽더라도 다른 프로세스에는 영향을 끼치지 않고 정상적으로 수행`된다는 장점이 있지만,      
멀티 스레드보다 `많은 메모리 공간과 CPU 시간을 차지한다는 단점`이 존재한다.       
   
이 두 가지는 동시에 여러 작업을 수행한다는 점에서 같지만 적용해야 하는 시스템에 따라 적합/부적합이 구분된다.      
따라서 **대상 시스템의 특징에 따라 적합한 동작 방식을 선택하고 적용해야 한다.**         
